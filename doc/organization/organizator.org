* Trabajo realizado cada día
** Antes del <2009-09-25 vie>

En este punto de inflexión del PFC, tengo que comenzar a hacer una
recapitulación de lo hecho hasta ahora, para ver como voy a afrontar el PFC.

Mi objetivo es terminarlo como sea antes de que empieze el mes de Diciembre, 
ya que la convocatoria va desde el <2009-12-14 lun> hasta el <2009-12-18 vie>,
y teniendo en cuenta el factor que hay que entregarlo una semana antes de 
dicha convocatoria, y que probablemente haya mucha gente pendiente, hay que
hacerlo lo antes posible. Es por eso que necesito algo de orden. Además, 
esto me sirve como recordatorio de lo que he estado haciendo, problemas 
encontrados y demás, para poder tenerlo todo agrupado a la hora de hacer la
memoria del proyecto.

A continuación voy a enumerar el estado actual del PFC:

+ Servidor SVN creado en local temporalmente, hasta que me habiliten la
  forja en RedIris. Una vez me la habiliten, solicitaré que migren mi 
  repositorio local para mantener todas las revisiones actuales.
+ Traducción del script en batch creado por Manuel, a Python haciendo uso
  de PyCLIPS. Ahora no es necesario el núcleo original para la ejecución
  del programa.

** <2009-09-25 vie>
*** <2009-09-25 vie 17:18> 

Fin de la organización preeliminar de este fichero. Comienza el análisis de
requisitos del sistema

*** <2009-09-25 vie 18:18>

Primer boceto de la ventana principal del PFC: file:../design_ui/mainWindow.dia
Quizás un splash estaría bien, así como organizar las opciones en dos columnas.

** <2009-09-26 sáb>
    CLOCK: [2009-09-26 sáb 14:26]--[2009-09-26 sáb 14:38] =>  0:12
    Comienzo a diseñar con Glade la ventana principal. A ver como queda.
    Voy a sacar dos versiones a ver como quedan :)
    <2009-09-26 sáb 14:38> Parón para comer

** <2009-09-28 lun>

Realizada la primera versión del menu principal, así como el diálogo "About"
En principio debería generar un fichero .glade para cada ventana. Sin embargo,
los diálogos predefinidos los voy a meter en el main, ya que me parece una
tontería tener que añadir un .glade para cada dialogo.

A ver si hoy me da tiempo a tener la navegación por todos los menus (una leche)

** <2009-09-29 mar>

Dado que ya hay una interfaz preeliminar para los menús, voy a intentar hacer una interfaz básica para las partidas en si.
Es un paso fundamental realmente, ya que necesito lo antes posible una interfaz que me permita trabajar con consola
lo menos posible.

Así que empiezo las pruebas con pygame para hacerme con la librería.

<2009-09-29 mar 19:35> De puta madre, acabo de lograr en branches que funcione
la clase Board que he definido para generar la surface de pygame con el tablero.
Sin embargo, falta funcionalidad para esa clase, además también me hace falta
revisar la clase Matrix, que no estoy yo muy convencido. Investigaré un poco
a ver si la puedo hacer más intuitiva

** <2009-09-30 mié>

Tras las tareitas de PF, toca seguir con el PFC. Ahora mismo llevo 3 frentes abiertos:

- Libguadalete, la API que se comunica con el auténtico nucleo del S.E. Tengo que hacer el nucleo amigable,
  sin que pierda funcionalidades, y dando el soporte necesario para las diversas tareas. Esto probablemente
  sea la tarea más dura de todo el PFC, ya que tendré que indagar en CLIPS, y como tiene montado Manolo el
  nucleo original.
- Menús. La parte de la GUI con PyGTK + Glade. No tiene demasiada ciencia, y ahora mismo tengo lo más básico,
  pero me sirve para una primera iteración del sistema.
- Tablero. Interfaz del juego en sí realizada con pygame, que muestra el juego.

La cosa es ¿con que me centro? Habrá que ordenar por prioridades, veamos:

- Sin duda los menus de GTK, dado el estado actual, tienen poca prioridad. Hay unos mínimos establecidos en la UI,
  y lo que queda son detalles secundarios. Lo primero es hacer correr el sistema, eso está claro.
- La duda es, ¿qué tiene más prioridad ahora mismo? ¿tablero ó libguadalete? Ahora mismo, libguadalete está muy
  incompleto, pero al menos es capaz de jugar una partida entre dos S.E. vacios y generar los ficheros. Por ahora, eso
  debería bastarme.
 
Así que el siguiente paso en el PFC es avanzar en la UI de pygame.

<2009-09-30 mié 18:07> Tablero iterado entero en pygame tras la ejecución de una partida. Ahora a modularlo todo mejor

* ToDo-list
** DONE [#A] Traducir nucleo original de CLIPS a Python haciendo uso de PyCLIPS
** DONE [#B] Inscribirme al CUSL4					  :CUSL:
** DONE [#A] Organizar los siguientes hitos y pasos a seguir	  :ORGANIZACION:
   SCHEDULED: <2009-09-25 vie> 
   DEADLINE: <2009-09-25 vie>
Para este paso tengo que tener claro que falta por hacer, crear una 
organización clara del proyecto, del tiempo que tengo disponible, y llevar 
un control de lo que hay que hacer, lo que está hecho y demás.
** TODO [#A] Realizar el Análisis del sistema			      :ANALISIS:
*** TODO [#A] Toma de requisitos funcionales
    SCHEDULED: <2009-09-25 vie>
    DEADLINE: <2009-09-27 dom>
*** TODO [#A] Análisis del sistema
    SCHEDULED: <2009-09-26 sáb>
    DEADLINE: <2009-09-28 lun>
*** TODO [#B] Análisis y diseño de la GUI
** TODO [#B] Hacer los bocetos de los distintos menús que tendrá el sistema
** TODO [#C] Probar Doxygen con Python
** TODO [#A] Reestructurar fichero de organización
   Organizar el fichero de organización para tener una estructura más clara
** DONE [#A] Revisar clase Matrix
   CLOSED: [2009-10-06 mar 09:35]
* Interfaz
** Menu principal
*** Partida rápida
*** Competiciones
*** Gestor de sistemas expertos
*** Laboratorio
*** Revisión de partidas
*** Configuración
* Estructura de ficheros
** file:../../../branches Branches de prueba
*** file:../../../branches/pygame-tests Algunas pruebas con pygame
- file:../../../branches/pygame-tests/pygame-board.py
** file:../../../tags Tags del proyecto
*** file:../../../tags/nucleo-guadalete-original Nucleo original del proyecto
** file:../../../trunk Rama principal de desarrollo
*** file:../../../trunk/doc Documentación del proyecto
*** file:../../../trunk/src Fuentes del proyecto
- file:../../../trunk/src/ejecucion.py
- file:../../../trunk/src/matrixBoard.py
- file:../../../trunk/src/parseOutput.py
**** file:../../../trunk/src/gui Pruebas con la UI
- file:../../../trunk/src/gui/gui-v1.py
- file:../../../trunk/src/gui/settings_dialog.py
- file:../../../trunk/src/gui/quick_game_dialog.py

* Objetivos del PFC

Para no perder la perspectiva en ningún momento voy a incluir esta lista
para indicar los objetivos que debo/quiero cumplir con este proyecto.

** Funcionales
- [ ] Otorgar una interfaz amigable para las pruebas de los sistemas expertos 
      diseñados e implementados e CLIPS por los usuarios.
- [ ] Implementar sistemas de competiciones (configurables)
- [ ] Pruebas de sistemas expertos: hacer jugar un sistema experto contra
      varios, sacar estadísticas, y mostrar al usuario como de bueno es
      el sistema experto que ha implementado.
- [ ] Modo rápido de partida (sin mostrar toda la partida).
- [ ] Posibilitar la ocultación de los valores de las fichas en el modo juego.
- [ ] Modo de prueba interactiva, es decir, jugar contra tu sistema experto.
- [ ] Sistema de almacenamiento de partidas.
- [ ] [OPCIONAL] Interfaz dinámica de edición de formaciones

** Transversales
- [ ] Código escrito en inglés.
- [ ] Internacionalizable.
- [ ] Diseño orientado a objetos.
- [ ] Modulable para futuras ampliaciones.
- [ ] Documentación al día (preparada para Doxygen).
      
* Cosas que preguntarle a Manolo
- [ ] Mostrarle el boceto de la UI. ¿Hacer una barra de menus repitiendo las
      opciones?

* Ideas sobre la marcha
- [ ] Ventanita de splash
- [ ] En futuras iteraciones, podría cambiar el entorno de juego, y en vez de usar 
      pygame, empotrar el tablero en una ventana GTK como lo hace
      gnome-games con el ajedrez por ejemplo. Eso quizás le de un aspecto más
      completo al sistema.


-------------------------------------------

* Bloques o componentes del sistema
** Libguadalete
*** Funciones
Otorgar una API clara para la interacción con el nucleo en CLIPS de 'La 
batalla del Guadalete'. 


* Algunos HowTo's
** Cargar fuente con pygame					:FUENTE::PYGAME:
   1) import pygame.font
   2) Creamos objeto de tipo SysFont: fuente = pygame.font.SysFont(name, tam,bold,italic)
      + name -> Nombre de la fuente del sistema. Ojo, puede que la fuente no
	esté instalada, así que usar una común
      + tam -> Tamaño de la fuente. Puede ser 44 o algo así para una ficha 60x60
      + bold e italic -> Booleanos para indicar si queremos negrita y cursiva
   3) Creamos una surface con el texto: 
      texto = fuente.render(text, antialias, color), donde:
      + text -> Cadena con el texto a renderizar
      + antialias -> Para hacer antialiasing (darle valor 1)
      + color -> típica tupla con los valores decimales del color 
   4) Si queremos centrar el texto en la surface donde lo vamos a copiar,
      hacemos el siguiente comando:
      textpos = texto.get_rect(centerx=background.get_width()/2, centery= background.get_width()/2)
      El cual nos devuelve un rect para blitear en la superficie que queramos
   5) Si background es la superficie donde queremos blitear:
      background.blit(texto, textpos)
   
